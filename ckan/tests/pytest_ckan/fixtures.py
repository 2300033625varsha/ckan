# -*- coding: utf-8 -*-
"""This is a collection of pytest fixtures for use in tests.

All fixtures below available anywhere under the root of CKAN
repository. Any external CKAN extension should be able to include them
automatically by installing `pytest-ckan` package.

There are five types of fixtures available in CKAN:

* Fixtures that have some side-effect. They don't return any useful
  value and generally should be injected via
  ``pytest.mark.usefixtures``. Ex.: `with_plugins`, `clean_db`,
  `clean_index`.

* Fixtures that provide value. Ex. `app`

* Fixtures that prvovide a callable for certain task. They are rarely needed,
  so prefer using 'side-effect' or 'value' fixtures. Main use-case when one may
  use function-fixture - late initialization or repeatable execution(ex.:
  cleaning database more than once in a single test). But presence of these
  fixtures in test usually signals that is's a good time to refactor this test.

* Fixtures data-factories. All of them has `*_factory` suffix. They represent
  data-factories from ``ckan.tests.factories`` modules. For example, CKAN
  registers fixture ``user_factory`` which is basically an alias for
  ``ckan.tests.factories.User``, ``dataset_factory`` which is an alias for
  ``ckan.tests.factories.Dataset``, etc.

* Fixtures data-instances. Every ``ENTITY_factory`` fixture has corresponding
  ``ENTITY`` fixture. I.e. ``user_factory``/``user``,
  ``dataset_factory``/``dataset``.  These are shortcuts for creating a single
  instance using data-factory. For example, instead of adding ``user_factory``
  to the test and calling it like this: ``user = user_factory()``, it's
  possible to include ``user`` fixture to test. This fixture will create an
  instance, generated by the corresponding factory-fixture.

Deeper explanation can be found in `official documentation
<https://docs.pytest.org/en/latest/fixture.html>`_

"""
from __future__ import annotations

import smtplib

from io import BytesIO
import copy
import inspect
from typing import Any, Type
from typing_extensions import TypeGuard

import pytest
import rq
import inflection

from werkzeug.datastructures import FileStorage as FlaskFileStorage
from pytest_factoryboy import register

import ckan.tests.helpers as test_helpers
import ckan.tests.factories as factories

import ckan.plugins
import ckan.cli
import ckan.model as model
from ckan.common import config, aslist
from ckan.lib import redis, search


def _is_factory_class(m: Any) -> TypeGuard[Type[factories.CKANFactory]]:
    """Select classes that can be used as factory fixtures.
    """
    return (
        isinstance(m, type)
        and issubclass(m, factories.CKANFactory)
        and m is not factories.CKANFactory
    )


# Register every subclass of CKANFactory as a fixture. It gives us two new
# fixtures for each factory. First fixture is created using the factory class
# name converted from camel-case to underscored form(`FirstFixtureClass` ->
# `first_fixture_class`). It's just an alias for original factory
# class(`first_fixture_class is FirstFixtureClass`). Second fixture is created
# by calling the first fixture without arguments(`second_fixture =
# first_fixture_class()`). We have to specify it's name explicitely. Let's take
# a look on artifacts that will be produced by
# `ckan.tests.factories.User`. We'll append `Factory` suffix to this class
# before registering the fixture, that's why first fixture will take the name
# `user_factory`.
#
#
# # user_factory  - factory-fixture
#
# it's just an alias for factories.User. Basic usage of factory class looks
# like this::
#
#     from ckan.tests import factories
#     def test_user():
#         user = factories.User()
#
# Factory fixture changes it to pytest-way::
#
#     def test_user(user_factory):
#         user = user_factory()
#
# Apart from different style, it gives you flexibility of pytest fixtures. You
# can define module-local version of ``user_factory`` or use parametrization.
#
# Because ``user_factory`` is just an alias for the factory class, you still
# can use all the features of factory, as:
# * custom properties: user_factory(name="Test", password="123")
# * get model instead of a dict: user_factory.model(name="Tes") # model.User
# * batch generation: user_factory.create_batch(100) # create 100 users
#
#
# # user  - instance-fixture
#
# This is a shortcut for creating an instance using factory. Roughly, this::
#
#     def test_something(user_factory):
#         user = user_factory()
#         ...
#
# is identical to this::
#
#     def test_something(user):
#         ...
#
# You just save one line and 8 characters(``_factory`` suffix). But apart from
# that it's still a pytest fixture. It means that all cool effects of fixtures
# is applicable to it. For example, if there is a fixture that depends on
# ``user``::
#
#     @pytest.fixture()
#     def user_from_somewhere(user):
#         return user
#
# and a test that requires both ``user`` and this fixture from above, they will
# share the same ``user``::
#
#     def test_identity(user, user_from_somewhere):
#         assert user is user_from_somewhere
#
#
# Details about factories and reference to pytest-factoryboy can be found in
# ckan.test.factories module
for (name, factory) in inspect.getmembers(factories, _is_factory_class):
    # Add `Factory` suffix to the factory class name. Class name will be
    # converted into a name for factory-fixture. We want it to be different
    # from the name of the instance-fixture. For end-user it will be more
    # clear, if factory-fixture use name `something_factory`, while instance
    # fixtures will use just `something`.
    #
    # If we use original class name, HelloWorld class will turn into
    # `hello_world` factory-fixture, that will be **an alias** for HelloWorld
    # class. It means, we won't be able to use `hello_world` identifier as and
    # instance name. We'll have to come up with something different, like
    # `hello_world_instance`. It's not so cool, because people want shorter
    # names for instances.
    #
    # That's why we are using `Factory` suffix. It will give us
    # `hello_world_factory` fixture and we'll be able to use `hello_world` as a
    # name for instance.
    if not name.endswith("Factory"):
        name += "Factory"

    # Create a new class with the "right" name(suffixed by `Factory`).
    cls = type(name, (factory, ), {})

    # this function creates both fixtures
    register(
        # name of the factory-fixture will be obtained from `cls.__name__`
        cls,
        # name of instance-fixture must be passed explicitly. Strip `Factory`
        # suffix from instance name and convert it to underscore-form.
        inflection.underscore(name[:-7])
    )


@pytest.fixture
def ckan_config(request, monkeypatch):
    """Allows to override the configuration object used by tests

    Takes into account config patches introduced by the ``ckan_config``
    mark.

    If you just want to set one or more configuration options for the
    scope of a test (or a test class), use the ``ckan_config`` mark::

        @pytest.mark.ckan_config('ckan.auth.create_unowned_dataset', True)
        def test_auth_create_unowned_dataset():

            # ...

    To use the custom config inside a test, apply the
    ``ckan_config`` mark to it and inject the ``ckan_config`` fixture:

    .. literalinclude:: /../ckan/tests/pytest_ckan/test_fixtures.py
       :start-after: # START-CONFIG-OVERRIDE
       :end-before: # END-CONFIG-OVERRIDE

    If the change only needs to be applied locally, use the
    ``monkeypatch`` fixture

    .. literalinclude:: /../ckan/tests/test_common.py
       :start-after: # START-CONFIG-OVERRIDE
       :end-before: # END-CONFIG-OVERRIDE

    """
    _original = copy.deepcopy(config)
    for mark in request.node.iter_markers(u"ckan_config"):
        monkeypatch.setitem(config, *mark.args)

    yield config
    config.clear()
    config.update(_original)


@pytest.fixture
def make_app(ckan_config):
    """Factory for client app instances.

    Unless you need to create app instances lazily for some reason,
    use the ``app`` fixture instead.
    """
    from ckan.lib.app_globals import _CONFIG_CACHE
    # Reset values cached during the previous tests. Otherwise config values
    # that were added to app_globals reset the patched versions from
    # `ckan_config` mark.
    _CONFIG_CACHE.clear()

    return test_helpers._get_test_app


@pytest.fixture
def app(make_app):
    """Returns a client app instance to use in functional tests

    To use it, just add the ``app`` parameter to your test function signature::

        def test_dataset_search(self, app):

            url = h.url_for('dataset.search')

            response = app.get(url)


    """
    return make_app()


@pytest.fixture
def cli(ckan_config):
    """Provides object for invoking CLI commands from tests.

    This is subclass of `click.testing.CliRunner`, so all examples
    from `Click docs
    <https://click.palletsprojects.com/en/master/testing/>`_ are valid
    for it.

    """
    env = {
        u'CKAN_INI': ckan_config[u'__file__']
    }
    return test_helpers.CKANCliRunner(env=env)


@pytest.fixture(scope=u"session")
def reset_db():
    """Callable for resetting the database to the initial state.

    If possible use the ``clean_db`` fixture instead.

    """
    factories.fake.unique.clear()
    return test_helpers.reset_db


@pytest.fixture(scope=u"session")
def reset_index():
    """Callable for cleaning search index.

    If possible use the ``clean_index`` fixture instead.
    """
    return search.clear_all


@pytest.fixture(scope="session")
def reset_redis():
    """Callable for removing all keys from Redis.

    Accepts redis key-pattern for narrowing down the list of items to
    remove. By default removes everything.

    This fixture removes all the records from Redis on call::

        def test_redis_is_empty(reset_redis):
            redis = connect_to_redis()
            redis.set("test", "test")

            reset_redis()
            assert not redis.get("test")

    If only specific records require removal, pass a pattern to the fixture::

        def test_redis_is_empty(reset_redis):
            redis = connect_to_redis()
            redis.set("AAA-1", 1)
            redis.set("AAA-2", 2)
            redis.set("BBB-3", 3)

            reset_redis("AAA-*")
            assert not redis.get("AAA-1")
            assert not redis.get("AAA-2")

            assert redis.get("BBB-3") is not None

    """
    def cleaner(pattern: str = "*") -> int:
        """Remove keys matching pattern.

        Return number of removed records.
        """
        conn = redis.connect_to_redis()
        keys = conn.keys(pattern)
        if keys:
            return conn.delete(*keys)
        return 0

    return cleaner


@pytest.fixture()
def clean_redis(reset_redis):
    """Remove all keys from Redis.

    This fixture removes all the records from Redis::

        @pytest.mark.usefixtures("clean_redis")
        def test_redis_is_empty():
            assert redis.keys("*") == []

    If test requires presence of some initial data in redis, make sure that
    data producer applied **after** ``clean_redis``::

        @pytest.mark.usefixtures(
            "clean_redis",
            "fixture_that_adds_xxx_key_to_redis"
        )
        def test_redis_has_one_record():
            assert redis.keys("*") == [b"xxx"]

    """
    reset_redis()


@pytest.fixture
def clean_db(reset_db):
    """Resets the database to the initial state.

    This can be used either for all tests in a class::

        @pytest.mark.usefixtures("clean_db")
        class TestExample(object):

            def test_example(self):

    or for a single test::

        class TestExample(object):

            @pytest.mark.usefixtures("clean_db")
            def test_example(self):

    """
    reset_db()


@pytest.fixture(scope="session")
def migrate_db_for():
    """Apply database migration defined by plugin.

    In order to use models defined by extension extra tables may be
    required. In such cases database migrations(that were generated by `ckan
    generate migration -p PLUGIN_NAME`) can be applied as per example below::

        @pytest.mark.usefixtures("clean_db")
        def test_migrations_applied(migrate_db_for):
            migrate_db_for("my_plugin")
            assert model.Session.bind.has_table("my_plugin_custom_table")

    """
    from ckan.cli.db import _run_migrations

    def runner(plugin, version="head", forward=True):
        assert plugin, "Cannot apply migrations of unknown plugin"
        _run_migrations(plugin, version, forward)

    return runner


@pytest.fixture
def clean_index(reset_index):
    """Clear search index before starting the test.
    """
    reset_index()


@pytest.fixture
def with_plugins(ckan_config):
    """Load all plugins specified by the ``ckan.plugins`` config option
    at the beginning of the test. When the test ends (even it fails), it will
    unload all the plugins in the reverse order.

    .. literalinclude:: /../ckan/tests/test_factories.py
       :start-after: # START-CONFIG-OVERRIDE
       :end-before: # END-CONFIG-OVERRIDE

    """
    plugins = aslist(ckan_config["ckan.plugins"])
    for plugin in plugins:
        if not ckan.plugins.plugin_loaded(plugin):
            ckan.plugins.load(plugin)
    yield
    for plugin in reversed(plugins):
        if ckan.plugins.plugin_loaded(plugin):
            ckan.plugins.unload(plugin)


@pytest.fixture
def test_request_context(app):
    """Provide function for creating Flask request context.
    """
    return app.flask_app.test_request_context


@pytest.fixture
def with_request_context(test_request_context):
    """Execute test inside requests context
    """
    with test_request_context():
        yield


@pytest.fixture
def mail_server(monkeypatch):
    """Catch all outcome mails.
    """
    bag = test_helpers.FakeSMTP()
    monkeypatch.setattr(smtplib, u"SMTP", bag)
    yield bag


@pytest.fixture
def with_test_worker(monkeypatch):
    """Worker that doesn't create forks.
    """
    monkeypatch.setattr(
        rq.Worker, u"main_work_horse", rq.SimpleWorker.main_work_horse
    )
    monkeypatch.setattr(
        rq.Worker, u"execute_job", rq.SimpleWorker.execute_job
    )
    yield


@pytest.fixture
def with_extended_cli(ckan_config, monkeypatch):
    """Enables effects of IClick.

    Without this fixture, only CLI command that came from plugins
    specified in real config file are available. When this fixture
    enabled, changing `ckan.plugins` on test level allows to update
    list of available CLI command.

    """
    # Main `ckan` command is initialized from config file instead of
    # using global config object.  With this patch it becomes possible
    # to apply per-test config changes to it without creating real
    # config file.
    monkeypatch.setattr(ckan.cli, u"load_config", lambda _: ckan_config)


@pytest.fixture(scope="session")
def reset_db_once(reset_db):
    """Internal fixture that cleans DB only the first time it's used.
    """
    reset_db()


@pytest.fixture
def non_clean_db(reset_db_once):
    """Guarantees that DB is initialized.

    This fixture either initializes DB if it hasn't been done yet or does
    nothing otherwise. If there is some data in DB, it stays intact. If your
    tests need empty database, use `clean_db` instead, which is much slower,
    but guarantees that there are no data left from the previous test session.

    Example::

        @pytest.mark.usefixtures("non_clean_db")
        def test_example():
            assert factories.User()

    """
    model.repo.init_db()


class FakeFileStorage(FlaskFileStorage):
    content_type = None

    def __init__(self, stream, filename):
        self.stream = stream
        self.filename = filename
        self.name = u"upload"


@pytest.fixture
def create_with_upload(clean_db, ckan_config, monkeypatch, tmpdir):
    """Shortcut for creating resource/user/org with upload.

    Requires content and name for newly created object. By default is
    using `resource_create` action, but it can be changed by passing
    named argument `action`.

    Upload field if configured by passing `upload_field_name` named
    argument. Default value: `upload`.

    In addition, accepts named argument `context` which will be passed
    to `ckan.tests.helpers.call_action` and arbitrary number of
    additional named arguments, that will be used as resource
    properties.

    Example::

        def test_uploaded_resource(create_with_upload):
            dataset = factories.Dataset()
            resource = create_with_upload(
                "hello world", "file.txt", url="http://data",
                package_id=dataset["id"])
            assert resource["url_type"] == "upload"
            assert resource["format"] == "TXT"
            assert resource["size"] == 11

    """
    monkeypatch.setitem(ckan_config, u'ckan.storage_path', str(tmpdir))

    def factory(data, filename, context={}, **kwargs):
        action = kwargs.pop("action", "resource_create")
        field = kwargs.pop("upload_field_name", "upload")
        test_file = BytesIO()
        if type(data) is not bytes:
            data = bytes(data, encoding="utf-8")
        test_file.write(data)
        test_file.seek(0)
        test_resource = FakeFileStorage(test_file, filename)

        params = {
            field: test_resource,
        }
        params.update(kwargs)
        return test_helpers.call_action(action, context, **params)
    return factory
